#version 460 core
#extension GL_EXT_shader_atomic_float : enable
#pragma debug(on)

const int SHLevel=4;

layout(local_size_x = SHLevel, local_size_y = 1) in;

struct DFGIRay{
    vec3 direction;
    vec3 hitPosition;
    vec3 flux;

    uint refCount;
    uint liveCount;
};

struct DFGISH{
    vec4 shCi[9];
};

layout(std430, binding = 0) buffer DFGIRaysBuffer{
    DFGIRay rays[];
};

layout(std430, binding = 1) buffer DFGISHBuffer{
    DFGISH sh[];
};

const int MAX_RAY_LIVE_COUNT=64;
uniform int GridContainsRays;
uniform vec3 SceneGridsResolution;
uniform vec3 GlobalSDFBoxMin;
uniform vec3 GlobalSDFBoxMax;

uint LinearGridIndex(ivec3 gridIndex){
    return uint(gridIndex.z*(SceneGridsResolution.x*SceneGridsResolution.y)+gridIndex.y*SceneGridsResolution.x+gridIndex.x);
} 

vec3 GridIndexToWorldPos(ivec3 gridIndex){
    vec3 gridSize=(GlobalSDFBoxMax-GlobalSDFBoxMin)/SceneGridsResolution;
    return GlobalSDFBoxMin+(vec3(gridIndex)+vec3(0.5))*gridSize;
}

float P(int l, int m, float x)
{
    // evaluate an Associated Legendre Polynomial P(l,m,x) at x
    float pmm = 1.0;
    if (m > 0) {
        float somx2 = sqrt((1.0 - x) * (1.0 + x));
        float fact = 1.0;
        for (int i = 1; i <= m; i++) {
            pmm *= (-fact) * somx2;
            fact += 2.0;
        }
    }
    if (l == m) return pmm;
    float pmmp1 = x * (2.0 * m + 1.0) * pmm;
    if (l == m + 1) return pmmp1;
    float pll = 0.0;
    for (int ll = m + 2; ll <= l; ++ll) {
        pll = ((2.0 * ll - 1.0) * x * pmmp1 - (ll + m - 1.0) * pmm) / (ll - m);
        pmm = pmmp1;
        pmmp1 = pll;
    }
    return pll;
}

int factorial(int v) {
    int res = 1;
    while (v > 1)
    {
        res *= v;
        v--;
    }
    return res;
}

const float PI = 3.14159265359;

float K(int l, int m)
{
    // renormalisation constant for SH function
    float temp = ((2.0 * l + 1.0) * factorial(l - m)) / (4.0 * PI * factorial(l + m));
    return sqrt(temp);
}

float SH(int l, int m, float theta, float phi)
{
    // return a point sample of a Spherical Harmonic basis function
    // l is the band, range [0..N]
    // m in the range [-l..l]
    // theta in the range [0..Pi]
    // phi in the range [0..2*Pi]
    const float sqrt2 = sqrt(2.0);
    if (m == 0) return K(l, 0) * P(l, m, cos(theta));
    else if (m > 0) return sqrt2 * K(l, m) * cos(m * phi) * P(l, m, cos(theta));
    else return sqrt2 * K(l, -m) * sin(-m * phi) * P(l, -m, cos(theta));
}

const ivec2 shTable[]={ivec2(0,0),ivec2(1,-1),ivec2(1,0),ivec2(1,1),ivec2(2,-2),ivec2(2,-1),ivec2(2,0),ivec2(2,1),ivec2(2,2)};

void main(){
    ivec3 gridIndex = ivec3(gl_WorkGroupID.xyz);
    vec3 gridWorldPos=GridIndexToWorldPos(gridIndex);
    uint linearGridIndex=LinearGridIndex(gridIndex);
    
    uint shIndex=gl_LocalInvocationID.x;
    vec3 ci=vec3(0);
    ivec2 shlm=shTable[shIndex];

    uint offset=LinearGridIndex(gridIndex)*GridContainsRays;
    for(int i=0;i<GridContainsRays;++i){
        DFGIRay ray=rays[offset+i];
        
        vec3 dir=-ray.direction;
        if(length(dir)<=0.01)
            continue;
        float theta=acos(dir.z);
        float phi=atan(dir.y/dir.x);
        vec3 flux=ray.flux; 
        float shValue=SH(shlm.x,shlm.y,theta,phi);
        ci+=shValue*flux;
        //rays[offset+i].flux/=2.0;
    }
    
    sh[linearGridIndex].shCi[shIndex]=vec4(ci,0);

}
