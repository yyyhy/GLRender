
#version 460 core
layout(local_size_x = 1, local_size_y = 1) in;
#extension GL_EXT_transform_feedback : enable
#pragma debug(on)

struct DFGIRay{
    vec3 direction;
    vec3 hitPosition;
    vec3 flux;

    uint refCount;
    uint liveCount;
};

struct GridLightInfo{
    vec3 Flux;
    vec3 ImportanceDirection;
    vec3 ImportancePosition;
};

layout(std430, binding = 0) buffer DFGIRaysBuffer{
    DFGIRay rays[];
};

// scene cellize
// 32 * 32 * 32 Grids, each grid contians 16 ray
// Downsample factor is 16 by default
layout(std430, binding = 1) buffer DFGIGridLightInfos{
    GridLightInfo infos[];
};

layout(std430, binding = 2) buffer DFGIRayCounterBuffer{
    uint gridRayCounter[];
};

const int MAX_RAY_LIVE_COUNT=64;
uniform vec3 SceneGridsResolution;
uniform vec3 GlobalSDFBoxMin;
uniform vec3 GlobalSDFBoxMax;

uint LinearGridIndex(ivec3 gridIndex){
    return uint(gridIndex.z*(SceneGridsResolution.x*SceneGridsResolution.y)+gridIndex.y*SceneGridsResolution.x+gridIndex.x);
} 

vec3 GridIndexToWorldPos(ivec3 gridIndex){
    vec3 gridSize=(GlobalSDFBoxMax-GlobalSDFBoxMin)/SceneGridsResolution;
    return GlobalSDFBoxMin+(vec3(gridIndex)+vec3(0.5))*gridSize;
}

void main(){
    ivec3 gridIndex = ivec3(gl_WorkGroupID.xyz);
    vec3 gridWorldPos=GridIndexToWorldPos(gridIndex);
    uint linearGridIndex=LinearGridIndex(gridIndex);
    uint offset=linearGridIndex*16;

    vec3 flux=vec3(0);
    vec3 direction=vec3(0);
    vec3 position=vec3(0);

    float cnt=0;

    for(int i=0;i<16;++i){
        DFGIRay ray=rays[offset+i];
        if(ray.liveCount>0){
            flux+=ray.flux;
            direction+=ray.direction;
            position+=ray.hitPosition;
            cnt++;
        }
        
    }

    if(cnt>0){
        flux/=cnt;
        direction/=cnt;
        position/=cnt;
    }
    
    GridLightInfo info;
    // info.Flux=flux;
    // info.ImportanceDirection=direction;
    // info.ImportancePosition=position;

const float MIX_FACTOR=0.01;

    GridLightInfo originInfo=infos[linearGridIndex];
    info.Flux=mix(originInfo.Flux,flux,MIX_FACTOR);
    info.ImportanceDirection=normalize(mix(originInfo.ImportanceDirection,direction,MIX_FACTOR));
    info.ImportancePosition=mix(originInfo.ImportancePosition,position,MIX_FACTOR);

    infos[linearGridIndex]=info;
}
