
#version 460 core

const int GRID_MAX_CONTAINS_RAY=1;

layout(local_size_x = GRID_MAX_CONTAINS_RAY, local_size_y = 1) in;
#pragma debug(on)

struct DFGIRay{
    vec3 direction;
    vec3 hitPosition;
    vec3 flux;

    uint refCount;
    uint liveCount;
};

struct GridLightInfo{
    vec3 Flux;
    vec3 ImportanceDirection;
    vec3 ImportancePosition;
};

layout(std430, binding = 0) buffer DFGIRaysBuffer{
    DFGIRay rays[];
};

// scene cellize
// 32 * 32 * 32 Grids, each grid contians 16 ray
// Downsample factor is 16 by default
#define RESULT_STORE_IN_TEX3D

#ifdef RESULT_STORE_IN_TEX3D
layout(binding=1,rgba32f) uniform image3D DFGIGridFlux;
layout(binding=2,rgba32f) uniform image3D DFGIGridImportanceDirection;
layout(binding=3,rgba32f) uniform image3D DFGIGridImportancePosition;
#else
layout(std430, binding = 1) buffer DFGIGridLightInfos{
    GridLightInfo infos[];
};
#endif


const int MAX_RAY_LIVE_COUNT=32;
uniform vec3 SceneGridsResolution;
uniform vec3 GlobalSDFBoxMin;
uniform vec3 GlobalSDFBoxMax;
uniform int GridContainsRays;
uint LinearGridIndex(ivec3 gridIndex){
    return uint(gridIndex.z*(SceneGridsResolution.x*SceneGridsResolution.y)+gridIndex.y*SceneGridsResolution.x+gridIndex.x);
} 

vec3 GridIndexToWorldPos(ivec3 gridIndex){
    vec3 gridSize=(GlobalSDFBoxMax-GlobalSDFBoxMin)/SceneGridsResolution;
    return GlobalSDFBoxMin+(vec3(gridIndex)+vec3(0.5))*gridSize;
}

float Power(vec3 l){
    return 0.299*l.x+0.587*l.y+0.114*l.z;
}

const float PI = 3.14159265359;

void main(){
    ivec3 gridIndex = ivec3(gl_WorkGroupID.xyz);
    vec3 gridWorldPos=GridIndexToWorldPos(gridIndex);
    uint linearGridIndex=LinearGridIndex(gridIndex);
    uint offset=linearGridIndex*GridContainsRays;

    vec3 flux=vec3(0);
    vec3 direction=vec3(0);
    vec3 position=vec3(0);

    float cnt=0;

    float totolPower=0;
    for(int i=0;i<GridContainsRays;++i){
        DFGIRay ray=rays[offset+i];
        if(ray.refCount>0){
            flux+=ray.flux*Power(ray.flux);
            direction+=ray.direction*Power(ray.flux);
            position+=ray.hitPosition*Power(ray.flux);
            totolPower+=Power(ray.flux);
            cnt++;
        }
        
    }

    if(cnt>0){
        flux/=totolPower;
        direction/=totolPower;
        position/=totolPower;
    }
    
    //direction=vec3(-1,0,0);
    // info.Flux=flux;
    // info.ImportanceDirection=direction;
    // info.ImportancePosition=position;
    const float MIX_FACTOR=0.02;

#ifdef RESULT_STORE_IN_TEX3D
    vec4 originFlux=imageLoad(DFGIGridFlux,gridIndex);
    vec4 originImportanceDirection=imageLoad(DFGIGridImportanceDirection,gridIndex);
    vec4 originImportancePosition=imageLoad(DFGIGridImportancePosition,gridIndex);

#ifdef AMD_PLATFORM
    imageStore(DFGIGridFlux,gridIndex,mix(originFlux,vec4(flux*2*PI,0),MIX_FACTOR));
    imageStore(DFGIGridImportanceDirection,gridIndex,normalize(mix(originImportanceDirection,vec4(normalize(direction),0),MIX_FACTOR)));
    imageStore(DFGIGridImportancePosition,gridIndex,mix(originImportancePosition,vec4(position,0),MIX_FACTOR));
#else
    imageStore(DFGIGridFlux,gridIndex,vec4(flux,0));
    if(direction.x!=0&&direction.y!=0&&direction.z!=0)
        imageStore(DFGIGridImportanceDirection,gridIndex,vec4(normalize(direction),0));
    else
        imageStore(DFGIGridImportanceDirection,gridIndex,vec4(0));
    imageStore(DFGIGridImportancePosition,gridIndex,vec4(position,0));
#endif

#else
    GridLightInfo info;
    GridLightInfo originInfo=infos[linearGridIndex];
    info.Flux=mix(originInfo.Flux,flux,MIX_FACTOR);
    info.ImportanceDirection=normalize(mix(originInfo.ImportanceDirection,direction,MIX_FACTOR));
    info.ImportancePosition=mix(originInfo.ImportancePosition,position,MIX_FACTOR);

    infos[linearGridIndex]=info;

#endif
}
